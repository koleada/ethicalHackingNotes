SSRF bible:
https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery lots of great info and tools here for SSRF
https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery/url-format-bypass great list of vectors
Server Side Request Forgery

Server-side request forgery is a web security vulnerability that allows an attacker 
to cause the server-side application to make requests to an unintended location.

In a typical SSRF attack, the attacker might cause the server to make a connection to internal-only services within the organization's infrastructure. In other cases, they may be able to force the server to connect to arbitrary external systems. This could leak sensitive data, such as authorization credentials.

Impacts: access unauthroized data, perform unauthorized actions. Could be to the server or other back-end systems. 

Basic SSRF & example:
In an SSRF attack against the server, the attacker causes the application to make an HTTP request back to the server that is hosting the application, via its loopback network interface. This typically involves supplying a URL with a hostname like 127.0.0.1 (a reserved IP address that points to the loopback adapter) or localhost (a commonly used name for the same adapter).

For example, imagine a shopping application that lets the user view whether an item is in stock in a particular store. To provide the stock information, the application must query various back-end REST APIs. It does this by passing the URL to the relevant back-end API endpoint via a front-end HTTP request. When a user views the stock status for an item, their browser makes the following request:

POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://stock.weliketoshop.net:8080/product/stock/check%3FproductId%3D6%26storeId%3D1
This causes the server to make a request to the specified URL, retrieve the stock status, and return this to the user.

In this example, an attacker can modify the request to specify a URL local to the server:

POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://localhost/admin
The server fetches the contents of the /admin URL and returns it to the user.

An attacker can visit the /admin URL, but the administrative functionality is normally only accessible to authenticated users. This means an attacker won't see anything of interest. However, if the request to the /admin URL comes from the local machine, the normal access controls are bypassed. The application grants full access to the administrative functionality, because the request appears to originate from a trusted location.

** APIs can be a great way to find references to backend servers. We can test these endpoings using a variety of paths such has 
http://localhost/admin (localhost = 127.0.0.1) Adding 127.0.0.1 to various HTTP request headers can be used to bypass WAFs as well.

-------------------------------------------------------------------------------------------------------------------------------------
Why do Applications implicitly trust requests from the local machine?
-The access control check might be implemented in a different component that sits in front of the application server. When a connection is made back to the server, the check is bypassed.
-For disaster recovery purposes, the application might allow administrative access without logging in, to any user coming from the local machine. This provides a way for an administrator to recover the system if they lose their credentials. This assumes that only a fully trusted user would come directly from the server.
-The administrative interface might listen on a different port number to the main application, and might not be reachable directly by users.
**these trust relationships (treating requests from local machine different than a regular request) often make SSRF a critical vuln
-------------------------------------------------------------------------------------------------------------------------------------
OFten there are other backend systems that can be reached through SSRF (find ips by network scanning) example of this below:

In some cases, the application server is able to interact with back-end systems that are not directly reachable by users. These systems often have non-routable private IP addresses. The back-end systems are normally protected by the network topology, so they often have a weaker security posture. In many cases, internal back-end systems contain sensitive functionality that can be accessed without authentication by anyone who is able to interact with the systems.

In the previous example, imagine there is an administrative interface at the back-end URL https://192.168.0.68/admin. An attacker can submit the following request to exploit the SSRF vulnerability, and access the administrative interface:

POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://192.168.0.68/admin

We could also set up a fuzzing attack to send many reqests quickly to identify possible backend systems by changing the IP. Used to 
"network" scan internally. ** ZAP fuzzer is infinitally better then burps even for simple tasks or laps use ZAP** 

** Whenever we see a reference to an internal file or a seperate IP address or really other types of api references we should examine these places heavily! **
-------------------------------------------------------------------------------------------------------------------------------------
Circumventing common SSRF defenses: 
It is common to see applications containing SSRF behavior together with defenses aimed at preventing malicious exploitation. Often, these defenses can be circumvented.
------------------------------------------------------------
Evasion Techniques:
Some applications block input containing hostnames like 127.0.0.1 and localhost, or sensitive URLs like /admin. In this situation, you can often circumvent the filter using the following techniques:

-Use an alternative IP representation of 127.0.0.1, such as **2130706433**, **017700000001**, or **127.1**.
-Register your own domain name that resolves to 127.0.0.1. You can use spoofed.burpcollaborator.net for this purpose.
-Obfuscate blocked strings using URL encoding or case variation.
-Provide a URL that you control, which redirects to the target URL. Try using different redirect codes, as well as different         protocols for the target URL. For example, switching from an http: to https: URL during the redirect has been shown to bypass some anti-SSRF filters.

** when encoding in hackvertor use URL_ENCODEALL ***